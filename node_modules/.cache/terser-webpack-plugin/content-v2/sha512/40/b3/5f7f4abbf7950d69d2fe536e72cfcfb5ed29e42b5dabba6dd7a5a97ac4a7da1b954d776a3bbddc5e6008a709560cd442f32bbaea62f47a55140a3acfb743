{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{421:function(a,t,s){\"use strict\";s.r(t);var n=s(42),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[s(\"h2\",{attrs:{id:\"jvm体系架构概述\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jvm体系架构概述\"}},[a._v(\"#\")]),a._v(\" JVM体系架构概述\")]),a._v(\" \"),s(\"img\",{attrs:{src:a.$withBase(\"/jvm/jvm.png\"),alt:\"dock\"}}),a._v(\" \"),s(\"h3\",{attrs:{id:\"类加载器-classloader\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#类加载器-classloader\"}},[a._v(\"#\")]),a._v(\" 类加载器 ClassLoader\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"负责加载class文件，class文件在\"),s(\"strong\",[a._v(\"文件开头有特定的文件标示\")]),a._v(\"，将class文件字节码内容加载到内存中，并将这些内容换成方法区中的运行时数据结构并且ClassLoader只负责class文件加载，至于是否可运行，则由执行引擎Execution Engine决定。\")]),a._v(\" \"),s(\"li\",[a._v(\"JVM中提供了三层的ClassLoader：\\n\"),s(\"ul\",[s(\"li\",[a._v(\"Bootstrap classLoader 启动类加载器:主要负责加载核心的类库(java.lang.*等)，构造ExtClassLoader和APPClassLoader\")]),a._v(\" \"),s(\"li\",[a._v(\"ExtClassLoader扩展类加载器：主要负责加载jre/lib/ext目录下的一些扩展的jar。\")]),a._v(\" \"),s(\"li\",[a._v(\"AppClassLoader应用程序类加载器：主要负责加载应用程序的主函数类\")])])])]),a._v(\" \"),s(\"h4\",{attrs:{id:\"双亲委派机制\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#双亲委派机制\"}},[a._v(\"#\")]),a._v(\" 双亲委派机制\")]),a._v(\" \"),s(\"p\",[a._v(\"+双亲委派模型的工作作过程是 ：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完全这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"这种设计有个好处是，如果有人想替换系统级别的类：String.java，篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了。所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。\")])]),a._v(\" \"),s(\"div\",{staticClass:\"custom-block tip\"},[s(\"p\",{staticClass:\"custom-block-title\"},[a._v(\"TIP\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"假设当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。\")])])]),a._v(\" \"),s(\"h4\",{attrs:{id:\"沙箱安全机制\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#沙箱安全机制\"}},[a._v(\"#\")]),a._v(\" 沙箱安全机制\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。\")]),a._v(\" \"),s(\"li\",[a._v(\"类装载器（class loader）：其中类装载器在3个方面对Java沙箱起作用\\n\"),s(\"ul\",[s(\"li\",[a._v(\"它防止恶意代码去干涉善意的代码；\")]),a._v(\" \"),s(\"li\",[a._v(\"它守护了被信任的类库边界；\")]),a._v(\" \"),s(\"li\",[a._v(\"它将代码归入保护域，确定了代码可以进行哪些操作。\")])])])]),a._v(\" \"),s(\"div\",{staticClass:\"custom-block tip\"},[s(\"p\",{staticClass:\"custom-block-title\"},[a._v(\"TIP\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"比如我定义了一个类名为String所在包为java.lang，因为这个类本来是属于jdk的，如果没有沙箱安全机制的话，这个类将会污染到我所有的String,但是由于沙箱安全机制，所以就委托顶层的bootstrap加载器查找这个类，如果没有的话就委托extsion,extsion没有就到aapclassloader，但是由于String就是jdk的源代码，所以在bootstrap那里就加载到了，先找到先使用，所以就使用bootstrap里面的String,后面的一概不能使用，这就保证了不被恶意代码污染\")])])]),a._v(\" \"),s(\"h3\",{attrs:{id:\"本地接口-native-interface\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#本地接口-native-interface\"}},[a._v(\"#\")]),a._v(\" 本地接口 Native Interface\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"本地接口的作用是融合不同的语言为java所用，它的初衷是融合C/C++程序。所以在内存中开辟了一块空间处理标记为native的代码。它的具体做法是本地方法栈（Native Method Stack）中登记native方法，在执行引擎（Execution Engine）执行是加载native libraies\")])]),a._v(\" \"),s(\"h3\",{attrs:{id:\"程序计数器-pc寄存器-program-counter-register\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#程序计数器-pc寄存器-program-counter-register\"}},[a._v(\"#\")]),a._v(\" 程序计数器（PC寄存器） Program Counter Register\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"每个线程都有一个程序计数器，是线程私有的。就是一个指针指向方法区中的方法字节码（用来存储下一条指令的地址，也就是即将要执行的指令代码）。这是个非常小的内存空间。如果是native方法，这个计数器是空的\")]),a._v(\" \"),s(\"li\",[a._v(\"该程序计数器用于完成分支、循环、跳转、异常处理、线程恢复等基础功能。该内存空间不会发生OOM错误。\")])]),a._v(\" \"),s(\"h3\",{attrs:{id:\"方法区-method-area\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#方法区-method-area\"}},[a._v(\"#\")]),a._v(\" 方法区 Method Area\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"供各线程共享的运行时内存区域。它存储了\"),s(\"strong\",[a._v(\"每一个类的结构信息\")]),a._v(\"（类的模板信息），例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。\")]),a._v(\" \"),s(\"li\",[a._v(\"方法区是规范，在不同的虚拟机里实现不同，最典型的是永久代(PermGen space) 1.7和元空间(Metaspace)1.8+\")]),a._v(\" \"),s(\"li\",[a._v(\"实例变量在堆内存中，和方法区无关\")])]),a._v(\" \"),s(\"h3\",{attrs:{id:\"栈-jave-stack\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#栈-jave-stack\"}},[a._v(\"#\")]),a._v(\" 栈 Jave Stack\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"栈也叫栈内存，主管java程序运行，是在线程创建时创建（线程私有），它的生命周期是跟随线程的生命周期。所以\"),s(\"em\",[a._v(\"对于栈来说不存在垃圾回收问题\")]),a._v(\"。\"),s(\"strong\",[a._v(\"8种基本类型变量 + 对象的引用变量 + 实例方法\")]),a._v(\"都是在函数的占内存中分配。\")]),a._v(\" \"),s(\"li\",[a._v(\"栈存储什么\\n\"),s(\"ul\",[s(\"li\",[a._v(\"本地变量：输入参数、输出参数以及方法内变量\")]),a._v(\" \"),s(\"li\",[a._v(\"栈操作：记录入栈、出栈操作\")]),a._v(\" \"),s(\"li\",[a._v(\"栈帧数据：包括类文件、方法等\")])])]),a._v(\" \"),s(\"li\",[a._v(\"StackOverflowError 栈溢出错误\\n\"),s(\"ul\",[s(\"li\",[a._v(\"简单理解就是栈被压爆了（简单操作就是递归且没结束条件），导致溢出\")])])])]),a._v(\" \"),s(\"div\",{staticClass:\"custom-block tip\"},[s(\"p\",{staticClass:\"custom-block-title\"},[a._v(\"TIP\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"栈管运行，堆管存储\")]),a._v(\" \"),s(\"li\",[a._v(\"栈和FIFO相反，先进后出\")]),a._v(\" \"),s(\"li\",[a._v(\"栈帧：**每个方法执行时都会创建一个栈帧，有用存储局部变量表、操作数栈、动态链接、方法出口等信息.**每个方法从调用直至执行完毕的过程，就对应着一个栈桢在虚拟机中从入栈到出栈的过程。\"),s(\"strong\",[a._v(\"栈的大小和具体JVM实现有关，通常在256K~756K之间，约等于1M左右。\")])])])]),a._v(\" \"),s(\"h3\",{attrs:{id:\"堆-heap\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#堆-heap\"}},[a._v(\"#\")]),a._v(\" 堆 Heap\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[s(\"img\",{attrs:{src:a.$withBase(\"/jvm/heap.png\"),alt:\"dock\"}})])]),a._v(\" \"),s(\"h3\",{attrs:{id:\"栈-、堆-、方法区交互关系\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#栈-、堆-、方法区交互关系\"}},[a._v(\"#\")]),a._v(\" 栈 、堆 、方法区交互关系\")]),a._v(\" \"),s(\"img\",{attrs:{src:a.$withBase(\"/jvm/relation.png\"),alt:\"dock\"}}),a._v(\" \"),s(\"div\",{staticClass:\"language-java extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[a._v(\"public\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[a._v(\"class\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[a._v(\"Person\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"{\")]),a._v(\"\\n    \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[a._v(\"public\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[a._v(\"void\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[a._v(\"getHello\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[a._v(\"String\")]),a._v(\" name\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\",\")]),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[a._v(\"int\")]),a._v(\" age\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\")\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"{\")]),a._v(\"\\n        \"),s(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[a._v(\"System\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\".\")]),a._v(\"out\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[a._v(\"println\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"(\")]),a._v(\"name \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[a._v(\"+\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token string\"}},[a._v('\"说TA\"')]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[a._v(\"+\")]),a._v(\" age \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[a._v(\"+\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token string\"}},[a._v('\"了\"')]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\")\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\";\")]),a._v(\"\\n    \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"}\")]),a._v(\"\\n\\n    \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[a._v(\"public\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[a._v(\"static\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[a._v(\"void\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[a._v(\"main\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[a._v(\"String\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"[\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"]\")]),a._v(\" args\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\")\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"{\")]),a._v(\"\\n        \"),s(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[a._v(\"Person\")]),a._v(\" p1 \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[a._v(\"=\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[a._v(\"new\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[a._v(\"Person\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\")\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\";\")]),a._v(\"\\n        p1\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[a._v(\"getHello\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token string\"}},[a._v('\"w\"')]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\",\")]),s(\"span\",{pre:!0,attrs:{class:\"token number\"}},[a._v(\"18\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\")\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\";\")]),a._v(\"\\n        \"),s(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[a._v(\"Person\")]),a._v(\" p2 \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[a._v(\"=\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[a._v(\"new\")]),a._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[a._v(\"Person\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\")\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\";\")]),a._v(\"\\n        p2\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\".\")]),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[a._v(\"getHello\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token string\"}},[a._v('\"s\"')]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\",\")]),s(\"span\",{pre:!0,attrs:{class:\"token number\"}},[a._v(\"24\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\")\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\";\")]),a._v(\"\\n    \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"}\")]),a._v(\"\\n\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[a._v(\"}\")]),a._v(\"\\n\")])])]),s(\"ul\",[s(\"li\",[a._v(\"上述代码中，\"),s(\"code\",[a._v(\"Person p1 | Person p2\")]),a._v(\"、\"),s(\"code\",[a._v(\"18 | 24 | w | s\")]),a._v(\"在栈中，属于栈的引用reference,以及本地变量\")]),a._v(\" \"),s(\"li\",[s(\"code\",[a._v(\"new Person() | new Person()\")]),a._v(\"保存在堆中，开辟内存空间保存对象信息。\")]),a._v(\" \"),s(\"li\",[a._v(\"而new Person() 、new Person()会在方法区开辟\"),s(\"strong\",[a._v(\"一块空间\")]),a._v(\"，保证Person这个类的结构信息\")])])])}),[],!1,null,null,null);t.default=e.exports}}]);","extractedComments":[]}