{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{376:function(l,e,v){\"use strict\";v.r(e);var t=v(14),_=Object(t.a)({},(function(){var l=this,e=l.$createElement,v=l._self._c||e;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":l.$parent.slotKey}},[v(\"h2\",{attrs:{id:\"垃圾回收器\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#垃圾回收器\"}},[l._v(\"#\")]),l._v(\" 垃圾回收器\")]),l._v(\" \"),v(\"h3\",{attrs:{id:\"gc垃圾回收算法和垃圾回收器的关系\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#gc垃圾回收算法和垃圾回收器的关系\"}},[l._v(\"#\")]),l._v(\" **GC垃圾回收算法和垃圾回收器的关系？\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"垃圾回收算法（计数、复制、标清、标整）是内存回收方法论，垃圾回收器是堆方法论的落地实现\")]),l._v(\" \"),v(\"li\",[l._v(\"目前还没有完美的垃圾回收器，只是对于不同场合，进行分代收集\")]),l._v(\" \"),v(\"li\",[l._v(\"四种主要类型的垃圾回收器\\n\"),v(\"ul\",[v(\"li\",[v(\"code\",[l._v(\"Serial 串行\")]),l._v(\"：它为单线程环境设计并且只使用一个线程进行垃圾回收，会暂停所有用户线程。不合适服务器环境。\")]),l._v(\" \"),v(\"li\",[v(\"code\",[l._v(\"Parallel 并行\")]),l._v(\"：多个垃圾收集器并行工作，此时用户线程也是暂停的，适应科学计算、大数据处理等弱交互场景。\")]),l._v(\" \"),v(\"li\",[v(\"code\",[l._v(\"CMS 并发\")]),l._v(\"：用户线程和垃圾回收线程同时执行（不一定并行，也可能交替执行），不需要停顿用户线程，适应对响应时间有要求的场景。\")]),l._v(\" \"),v(\"li\",[v(\"code\",[l._v(\"G1\")])])])])]),l._v(\" \"),v(\"h3\",{attrs:{id:\"怎么查看生产上垃圾回收器是哪个-生产上如何配置垃圾回收器的\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#怎么查看生产上垃圾回收器是哪个-生产上如何配置垃圾回收器的\"}},[l._v(\"#\")]),l._v(\" **怎么查看生产上垃圾回收器是哪个？生产上如何配置垃圾回收器的\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[v(\"code\",[l._v(\"java -XX:+PrintCommandLineFlags -version\")]),l._v(\"查看默认垃圾回收器\\n\"),v(\"ul\",[v(\"li\",[l._v(\"默认Parallel\")])])]),l._v(\" \"),v(\"li\",[l._v(\"配置垃圾回收器有哪些\")])]),l._v(\" \"),v(\"hr\"),l._v(\" \"),v(\"h4\",{attrs:{id:\"垃圾回收器图\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#垃圾回收器图\"}},[l._v(\"#\")]),l._v(\" 垃圾回收器图\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[v(\"code\",[l._v(\"Serial\")]),l._v(\" \"),v(\"code\",[l._v(\"Parallel\")]),l._v(\" \"),v(\"code\",[l._v(\"ParNew\")]),l._v(\"是运行在新生代的垃圾回收器\")])]),l._v(\" \"),v(\"li\",[v(\"p\",[v(\"code\",[l._v(\"Serial MSC\")]),l._v(\" \"),v(\"code\",[l._v(\"Parallel Old\")]),l._v(\" \"),v(\"code\",[l._v(\"CMS\")]),l._v(\"是运行在老年代的垃圾回收器\")])]),l._v(\" \"),v(\"li\",[v(\"p\",[l._v(\"确定了新生代的垃圾回收器，系统会自动选择匹配的老年代垃圾回收器\")])]),l._v(\" \"),v(\"li\",[v(\"p\",[l._v(\"G1回收器是跨越新生代、老年代的垃圾回收器\")])]),l._v(\" \"),v(\"li\",[v(\"p\",[l._v(\"X号的表示被废弃的组合\\n\"),v(\"img\",{attrs:{src:l.$withBase(\"/jvm/gcq1.png\"),alt:\"dock\"}})]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"UseSerialGC\")]),l._v(\" \"),v(\"li\",[l._v(\"UseParallelGC\")]),l._v(\" \"),v(\"li\",[l._v(\"UseConcMarkSweepGC  (CMS 是缩写)\")]),l._v(\" \"),v(\"li\",[l._v(\"UseParNewGC (只在新生代使用并行垃圾回收器)\")]),l._v(\" \"),v(\"li\",[l._v(\"UseParallelOldGC (只在老年代使用并行垃圾回收器)\")]),l._v(\" \"),v(\"li\",[l._v(\"UseG1GC\")])])]),l._v(\" \"),v(\"li\",[v(\"p\",[l._v(\"如何选择垃圾回收器\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"预先参数说明（PrintGCDetails 看的参数对应）\\n\"),v(\"ul\",[v(\"li\",[l._v(\"DefNew -> Default New Generation\")]),l._v(\" \"),v(\"li\",[l._v(\"Tenured -> old\")]),l._v(\" \"),v(\"li\",[l._v(\"ParNew -> Parallel New Generation\")]),l._v(\" \"),v(\"li\",[l._v(\"PSYoungGen -> Parallel Scavenge\")]),l._v(\" \"),v(\"li\",[l._v(\"ParOldGen -> Parallel Old Generation\")])])]),l._v(\" \"),v(\"li\",[l._v(\"Server/Client模式 （只需掌握Server模式，Client模式基本不用）\\n\"),v(\"ul\",[v(\"li\",[l._v(\"32位win系统，默认Client模式\")]),l._v(\" \"),v(\"li\",[l._v(\"32位其它系统，2G内存同时2个CPU以上Server模式，低于该配置Client模式\")]),l._v(\" \"),v(\"li\",[l._v(\"64位都是Server模式\")])])])])])]),l._v(\" \"),v(\"h4\",{attrs:{id:\"新生代收集器\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#新生代收集器\"}},[l._v(\"#\")]),l._v(\" 新生代收集器\")]),l._v(\" \"),v(\"h5\",{attrs:{id:\"_1-serial串行收集器\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-serial串行收集器\"}},[l._v(\"#\")]),l._v(\" 1.Serial串行收集器\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"Serial串行收集器 是最稳定最高效的收集器，缺点是会暂停用户线程，对于单核CPU，没有线程交互使用此收集器可以获取最高的垃圾回收效率。\\n\"),v(\"ul\",[v(\"li\",[l._v(\"因此Serial垃圾回收器是java虚拟机运行在Client模式下的新生代垃圾回收器\")]),l._v(\" \"),v(\"li\",[l._v(\"开启 \"),v(\"code\",[l._v(\"-XX:+UseSerialGC\")]),l._v(\",开启后默认使用 \"),v(\"strong\",[l._v(\"Serial + Serial old\")]),l._v(\"收集器组合\\n\"),v(\"ul\",[v(\"li\",[l._v(\"表示新生代老年代都使用串行垃圾回收器，新生代复制算法，老年代标记-整理算法\")])])])])])]),l._v(\" \"),v(\"h5\",{attrs:{id:\"_2-parnew-并行收集器\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-parnew-并行收集器\"}},[l._v(\"#\")]),l._v(\" 2.ParNew 并行收集器\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"ParNew并行收集器 其实就是Serial的并行多线程版本，最常见的应用场景是配合老年代的GMS GC工作。它是很多java虚拟机运行在Server模式下的默认垃圾回收器\\n\"),v(\"ul\",[v(\"li\",[l._v(\"开启\"),v(\"code\",[l._v(\"-XX:+UseParNewGC\")]),l._v(\",开启后会使用\"),v(\"strong\",[l._v(\"ParNew + Serial old\")]),l._v(\"收集器组合\\n\"),v(\"ul\",[v(\"li\",[l._v(\"表示新生代老年代都使用串行垃圾回收器，\"),v(\"strong\",[l._v(\"新生代并行复制算法，老年代标记-整理算法\")])])])])])])]),l._v(\" \"),v(\"div\",{staticClass:\"custom-block tip\"},[v(\"p\",{staticClass:\"custom-block-title\"},[l._v(\"TIP\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"但是ParNew + Tenured（ParNew + Serial old）这样搭配已经不推荐\")]),l._v(\" \"),v(\"li\",[l._v(\"这个组合新生代回收时并行，老年代回收时串行\")])])]),l._v(\" \"),v(\"h5\",{attrs:{id:\"_3-parallelscavenge收集器\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-parallelscavenge收集器\"}},[l._v(\"#\")]),l._v(\" 3.ParallelScavenge收集器\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[l._v(\"ParallelScavenge收集器 是一个类似ParNew,也是一个新生代垃圾收集器，新生代老年代都是串行化。\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"开启\"),v(\"code\",[l._v(\"-XX:+UseParallelGC\")]),l._v(\"或\"),v(\"code\",[l._v(\"-XX:+UseParallelOldGC\")]),l._v(\"可相互激活（二选一都可），不配置系统默认就是这个\")])])]),l._v(\" \"),v(\"li\",[v(\"p\",[l._v(\"它关注重点是：\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"可控的吞吐量(Thoughput=运行用户代码时间/(运行用户代码时间+垃圾回收时间)，即比如运行运行100分钟，垃圾回收1分钟。吞吐量就是99%)。高吞吐量意味着高效利用CPU时间，它多用于在后台运算而不需要太多交互的任务。（比如job？）\")]),l._v(\" \"),v(\"li\",[l._v(\"自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。（自适应调节策略：虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数提供最适合的停顿时间（-XX:MaxGCPauseMillis）或最大吞吐量）\")])]),l._v(\" \"),v(\"div\",{staticClass:\"custom-block tip\"},[v(\"p\",{staticClass:\"custom-block-title\"},[l._v(\"TIP\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"-XX:ParallelGCThreads=数字N，可配置GC线程个数\\n\"),v(\"ul\",[v(\"li\",[l._v(\"CPU > 8 N= 5/8\")]),l._v(\" \"),v(\"li\",[l._v(\"CPU < 8 N = 实际数\")])])])])]),l._v(\" \"),v(\"h4\",{attrs:{id:\"老年代收集器\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#老年代收集器\"}},[l._v(\"#\")]),l._v(\" 老年代收集器\")]),l._v(\" \"),v(\"h5\",{attrs:{id:\"_4-parallelold收集器\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-parallelold收集器\"}},[l._v(\"#\")]),l._v(\" 4.ParallelOld收集器\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"ParallelOld收集器是ParallelScavenge收集器的老年代版本，使用\"),v(\"strong\",[l._v(\"多线程标记-整理算法\")])]),l._v(\" \"),v(\"li\",[l._v(\"jdk8以后可以考虑Parallel Scavenge + Parallel Old搭配（ParallelOld是jdk6以后提供，jdk6之前默认 ParallelScavenge + Serial Old搭配）\\n\"),v(\"ul\",[v(\"li\",[l._v(\"开启\"),v(\"code\",[l._v(\"-XX:+UseParallelOldGC\")])])])])]),l._v(\" \"),v(\"h5\",{attrs:{id:\"_5-cms-concmarksweep-并发标记清除收集器\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-cms-concmarksweep-并发标记清除收集器\"}},[l._v(\"#\")]),l._v(\" 5.CMS（ConcMarkSweep）并发标记清除收集器\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"CMS收集器是一种 \"),v(\"strong\",[l._v(\"获取最短回收停顿时间为目标的收集器。\")]),l._v(\" 适应互联网或者B/S系统服务器，这类应用重视服务响应速度，希望系统停顿时间最短。\")]),l._v(\" \"),v(\"li\",[l._v(\"CMS非常适合堆内存大，CPU核数多的服务端应用，也是G1出现前的首选收集器。\")]),l._v(\" \"),v(\"li\",[l._v(\"用户线程和GC线程并发\\n\"),v(\"ul\",[v(\"li\",[l._v(\"开启\"),v(\"code\",[l._v(\"-XX:+UseConcMarkSweepGC\")]),l._v(\"，开启后新生代默认使用ParNew。\")]),l._v(\" \"),v(\"li\",[l._v(\"开启后，收集器组合是 \"),v(\"code\",[l._v(\"ParNew(新生代) + CMS（老年代）+Serial old（老年代）\")]),l._v(\" 的组合，Serial Old是作为CMS出错后的后备收集器。\")])])]),l._v(\" \"),v(\"li\",[l._v(\"CMS运行的4步过程\\n\"),v(\"ul\",[v(\"li\",[l._v(\"初始标记 ：只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有工作线程\")]),l._v(\" \"),v(\"li\",[l._v(\"并发标记 ：进行GC Roots跟踪过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象\")]),l._v(\" \"),v(\"li\",[l._v(\"重新标记 : 为了修正并发标记过程中，因用户程序运行产生的一小部分对象变动。仍然需要暂停所有工作线程\")]),l._v(\" \"),v(\"li\",[l._v(\"并发清除 ：清除了GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。\")])])])]),l._v(\" \"),v(\"div\",{staticClass:\"custom-block tip\"},[v(\"p\",{staticClass:\"custom-block-title\"},[l._v(\"TIP\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"由于耗时最长的 \"),v(\"strong\",[l._v(\"并发标记 + 并发清除\")]),l._v(\"都是和用户线程一起工作，所以总体可以看作CMS垃圾回收和用户线程是并发执行。\")]),l._v(\" \"),v(\"li\",[l._v(\"优点：并发收集低停顿\")]),l._v(\" \"),v(\"li\",[l._v(\"缺点：1.并发堆CPU压力比较大（由于CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，会触发Serial Old进行GC，从而造成较大停顿）2.采用标记清除算法会产生大量空间碎片\")]),l._v(\" \"),v(\"li\",[l._v(\"由于标记清除无法处理空间碎片，老年代空间迟早会被耗尽，最后不得不通过担保机制Serial Old来对内存压缩。CMS也提供了参数-XX:CMSFullGCsBeForeCompaction(默认0，即每次都进行内存整理)来指定多少次CMS收集以后，进行一次压缩的Full GC\")])])]),l._v(\" \"),v(\"h5\",{attrs:{id:\"_6-serialold收集器\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6-serialold收集器\"}},[l._v(\"#\")]),l._v(\" 6.SerialOld收集器\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"Serial Old垃圾收集器是Serial的老年代版本，同样是单线程收集器，使用的是\"),v(\"strong\",[l._v(\"标记-整理算法\")]),l._v(\"，也是client默认的老年代收集器\\n\"),v(\"ul\",[v(\"li\",[l._v(\"作为CMS收集器的后备老年代收集器（实际JDK8+已经淘汰掉了，不主动配置此收集器）\")])])])])])]),l._v(\" \"),v(\"h4\",{attrs:{id:\"组合选择\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#组合选择\"}},[l._v(\"#\")]),l._v(\" 组合选择\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"单CPU小内存\\n\"),v(\"ul\",[v(\"li\",[v(\"code\",[l._v(\"-XX:+UseSerialGC\")])])])]),l._v(\" \"),v(\"li\",[l._v(\"多CPU，需要大吞吐量，接受小停顿\\n\"),v(\"ul\",[v(\"li\",[v(\"code\",[l._v(\"-XX:+UseParllelGC\")]),l._v(\" 或 \"),v(\"code\",[l._v(\"-XX:+UseParllelOldGC\")])])])]),l._v(\" \"),v(\"li\",[l._v(\"多CPU，追求低停顿，快速响应\\n\"),v(\"ul\",[v(\"li\",[v(\"code\",[l._v(\"-XX:+UseConcMarkSweepGC\")]),l._v(\" \"),v(\"code\",[l._v(\"-XX:+ParNewGC\")])])])])]),l._v(\" \"),v(\"table\",[v(\"thead\",[v(\"tr\",[v(\"th\",[l._v(\"参数\")]),l._v(\" \"),v(\"th\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"新生代收集器\")]),l._v(\" \"),v(\"th\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"新生代算法\")]),l._v(\" \"),v(\"th\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"老年代收集器\")]),l._v(\" \"),v(\"th\",{staticStyle:{\"text-align\":\"right\"}},[l._v(\"老年代算法\")])])]),l._v(\" \"),v(\"tbody\",[v(\"tr\",[v(\"td\",[v(\"code\",[l._v(\"-XX:+UseSerialGC\")])]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"Serial\")]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"复制\")]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"Serial Old\")]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"right\"}},[l._v(\"标整\")])]),l._v(\" \"),v(\"tr\",[v(\"td\",[v(\"code\",[l._v(\"-XX:+UseParNewGC\")])]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"ParNew\")]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"复制\")]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"Serial Old\")]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"right\"}},[l._v(\"标整\")])]),l._v(\" \"),v(\"tr\",[v(\"td\",[v(\"code\",[l._v(\"-XX:+UseParallelGC\")]),l._v(\" \"),v(\"code\",[l._v(\"-XX:+UseParallelOldGC\")])]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"Parallel[Scavenge]\")]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"复制\")]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"Parallel Old\")]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"right\"}},[l._v(\"标整\")])]),l._v(\" \"),v(\"tr\",[v(\"td\",[v(\"code\",[l._v(\"-XX:+UseConcMarkSweepGC\")])]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"ParNew\")]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"复制\")]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"CMS + Serial Old\")]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"right\"}},[l._v(\"标清\")])]),l._v(\" \"),v(\"tr\",[v(\"td\",[v(\"code\",[l._v(\"-XX:+UseG1GC\")])]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"G1整体使用标记-整理算法\")]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}},[l._v(\"局部使用复制算法，不会产生内存碎片\")]),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"center\"}}),l._v(\" \"),v(\"td\",{staticStyle:{\"text-align\":\"right\"}})])])]),l._v(\" \"),v(\"h3\",{attrs:{id:\"g1垃圾回收器\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#g1垃圾回收器\"}},[l._v(\"#\")]),l._v(\" **G1垃圾回收器\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"G1收集器是一款面向服务端应用的收集器，它像CMS一样，能与应用程序线程并发执行。\")]),l._v(\" \"),v(\"li\",[l._v(\"G1目标是取代CMS，相比CMS，以下表现更出色\\n\"),v(\"ul\",[v(\"li\",[l._v(\"G1有整理内存的过程，不会产生内存碎片。\")]),l._v(\" \"),v(\"li\",[l._v(\"G1的Stop The World(stw)更可控，G1在停顿时间上增加了预测机制，用户可以指定期望停顿时间\"),v(\"code\",[l._v(\"-XX:MaxGCPauseMillis=n\")]),l._v(\"。\")])])]),l._v(\" \"),v(\"li\",[l._v(\"主要改变时Eden Survivor Tenured等区域不是连续的了（以前这三个区域是一块连续的内存），而是变成了一个个大小一样的region,每个region从1m~32m不等。一个region有可能属于Eden，Survivor或者Tenured内存区域\"),v(\"code\",[l._v(\"-Xmx32g\")]),l._v(\"。\")])]),l._v(\" \"),v(\"h4\",{attrs:{id:\"g1特点\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#g1特点\"}},[l._v(\"#\")]),l._v(\" G1特点\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"G1重复利用多CPU、多核硬件优势，尽量缩短STW。\\n\"),v(\"ul\",[v(\"li\",[l._v(\"解释：多CPU可以同时处理多个region\")])])]),l._v(\" \"),v(\"li\",[l._v(\"G1整体采用标记-整理算法，局部复制算法，不会有内存碎片\")]),l._v(\" \"),v(\"li\",[l._v(\"G1讲把Eden、Survivor、Tenured混合再一起了，微观上还是保留了新生代老年代，它们变成了一些region的集合且不需要region是连续的，也就是说还是会采用不同的GC方式来处理不同的region\")]),l._v(\" \"),v(\"li\",[l._v(\"G1虽然区分新生代老年代，但不是物理上的区别。G1只是逻辑上的分代概念，或者说每个region都可能随G1的运行在不同代之间切换。\")])]),l._v(\" \"),v(\"h4\",{attrs:{id:\"g1底层原理\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#g1底层原理\"}},[l._v(\"#\")]),l._v(\" G1底层原理\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[l._v(\"region区域化垃圾收集器\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"最大好处化整为零，避免全内存扫描，只需要按区域region进行扫描\")]),l._v(\" \"),v(\"li\",[l._v(\"G1不要求堆内存存储在物理上连续，只需要逻辑连续即可。启动时可以通过参数\"),v(\"code\",[l._v(\"-XX:G1HeapRegionSize=n\")]),l._v(\"来指定分区大小(1~32m，且必须是2的幂)，默认将整个堆分为2048个region(所以最大支持内存为 32m*2048 =64G)\")]),l._v(\" \"),v(\"li\",[l._v(\"G1仍然属于分代收集器，一些region属于新生代，新生代垃圾收集器仍然会采用暂停所有用户线程的方式，把活着对象转到Surivor的region空间或者Tenured的region空间\")]),l._v(\" \"),v(\"li\",[l._v(\"一部分Tenured的region，G1收集器通过将对象从一个region复制到另一个region,完成清理工作，意味着这个过程中，G1完成了堆的整理（至少是部分的堆整理），解决了内存碎片问题。\")]),l._v(\" \"),v(\"li\",[l._v(\"在G1中还存在一个特殊的region区域，叫Humongous(巨大的)区域。如果一个对象占用空间超过的region分区容量50%以上，G1会认为其是大对象**默认分配到Tenured区域。**但它又是一个短期存在的对象，为了避免对垃圾回收器产生负面影响，G1专门划了Humongous区域，存放大对象，如果大对象占用空间超过了一个region,G1会寻找多个连续的region来存放，为了能找到连续的分区，有时候不得不启动Full GC\")])])]),l._v(\" \"),v(\"li\",[v(\"p\",[l._v(\"回收步骤\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"针对Eden区域回收，Eden区被耗尽会触发回收，主要是小区域收集+形成连续的内存块，避免内存碎片\\n\"),v(\"ul\",[v(\"li\",[l._v(\"Eden区数据移动到Surivor区，加入Surivor区内存不够，Eden区部分数据会晋升到Tenured区\")]),l._v(\" \"),v(\"li\",[l._v(\"Surivor区数据移动到新的Surivor区，部分会晋升到Tenured区\")]),l._v(\" \"),v(\"li\",[l._v(\"最后Eden区收拾干净了，GC结束用户应用程序线程继续\")])])])])]),l._v(\" \"),v(\"li\",[v(\"p\",[l._v(\"4步过程\")]),l._v(\" \"),v(\"ul\",[v(\"li\",[l._v(\"初始标记：只标记GC Roots可达的对象\")]),l._v(\" \"),v(\"li\",[l._v(\"并发标记: 进行GC Roots Tracing过程\")]),l._v(\" \"),v(\"li\",[l._v(\"最终标记：修正并发标记过程中变动的对象\")]),l._v(\" \"),v(\"li\",[l._v(\"筛选回收：根据时间来进行最大化回收\")])])])])])}),[],!1,null,null,null);e.default=_.exports}}]);","extractedComments":[]}