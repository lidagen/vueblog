{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{478:function(e,a,t){\"use strict\";t.r(a);var r=t(42),_=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[t(\"h2\",{attrs:{id:\"rabbitmq-高级\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#rabbitmq-高级\"}},[e._v(\"#\")]),e._v(\" RabbitMQ 高级\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"一、rabbitmq高级特性\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、rabbitmq高级特性\"}},[e._v(\"#\")]),e._v(\" 一、RabbitMQ高级特性\")]),e._v(\" \"),t(\"h4\",{attrs:{id:\"_1-消息可靠投递-producer到mq\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-消息可靠投递-producer到mq\"}},[e._v(\"#\")]),e._v(\" 1.消息可靠投递 \"),t(\"code\",[e._v(\"Producer到MQ\")])]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"在使用RabbitMQ的时候，作为消息发送方希望杜绝消息丢失或者投递失败。RabbitMQ为我们提供两种方式控制消息的可靠性投递\\n\"),t(\"ul\",[t(\"li\",[e._v(\"confirm 确认模式\")]),e._v(\" \"),t(\"li\",[e._v(\"return 退回模式\")])])]),e._v(\" \"),t(\"li\",[e._v(\"rabbitmq整个消息投递过程是 \"),t(\"code\",[e._v(\"producer -> exchange ->queue ->consumer\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"消息从\"),t(\"code\",[e._v(\"producer->exchange\")]),e._v(\"则会返回一个callback\")]),e._v(\" \"),t(\"li\",[e._v(\"ConfirmCallback.confirm回调方法\\n\"),t(\"ul\",[t(\"li\",[e._v(\"CorrelationData correlationData 相关配置信息\")]),e._v(\" \"),t(\"li\",[e._v(\"boolean ack 布尔值，true说明exchange接收到信息\")]),e._v(\" \"),t(\"li\",[e._v(\"String cause 失败原因\")])])])])])]),e._v(\" \"),t(\"div\",{staticClass:\"language-sh extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-sh\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[e._v(\"#properties配置\")]),e._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[e._v(\"#开启confirm\")]),e._v(\"\\nspring.rabbitmq.publisher-confirm-type\"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[e._v(\"=\")]),e._v(\"correlated \\n\")])])]),t(\"ul\",[t(\"li\",[e._v(\"消息从\"),t(\"code\",[e._v(\"exchange->queue\")]),e._v(\"投递有一个ReturnsCallback.returnedMessage\\n\"),t(\"ul\",[t(\"li\",[e._v(\"ReturnedMessage returnedMessage 对象里分别是 错误对象、错误码、错误信息、交换机、路由键信息\")])])])]),e._v(\" \"),t(\"div\",{staticClass:\"language-sh extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-sh\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[e._v(\"#properties配置\")]),e._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[e._v(\"#开启retrunCallback\")]),e._v(\"\\nspring.rabbitmq.publisher-returns\"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[e._v(\"=\")]),e._v(\"true\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[e._v(\"#设置交换机处理失败消息模式\")]),e._v(\"\\nspring.rabbitmq.template.mandatory\"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[e._v(\"=\")]),e._v(\"true\\n\")])])]),t(\"ul\",[t(\"li\",[e._v(\"我们利用这两个Callback控制消息可靠性投递\")])]),e._v(\" \"),t(\"h4\",{attrs:{id:\"_2-consumer-ack-mq到consumer\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-consumer-ack-mq到consumer\"}},[e._v(\"#\")]),e._v(\" 2.Consumer ACK \"),t(\"code\",[e._v(\"MQ到Consumer\")])]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"ack 指的是Acknowledge,确认。表示消费者接收到消息的确认方式\")]),e._v(\" \"),t(\"li\",[e._v(\"ack有三种确认方式\\n\"),t(\"ul\",[t(\"li\",[e._v('自动确认：acknowledge = \"none\"')]),e._v(\" \"),t(\"li\",[e._v('手动确认：acknowledge = \"manual\"')]),e._v(\" \"),t(\"li\",[e._v('根据异常情况确认：acknowledge = \"auto\"')])])]),e._v(\" \"),t(\"li\",[e._v(\"其中自动确认是指，当消息一旦被consumer接收，则自动确认收到，并将message从MQ缓存中删除，但实际业务中，有可能发生消息接收成功，业务处理失败,那么消息就会丢失。如果设置了手动确认方式，则需要在业务处理成功后，调用channel.basicACK()；手动签收，如果出现异常，则调用channel.basicNack()方法，让其再次发送消息。\")]),e._v(\" \"),t(\"li\",[e._v(\"消息监听实现ChannelAwareMessageListener接口，手动业务对正常业务basicACK(),异常basicNack()\")])]),e._v(\" \"),t(\"div\",{staticClass:\"language-sh extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-sh\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[e._v(\"#properties配置\")]),e._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[e._v(\"#开启direct类型exchange手动ack\")]),e._v(\"\\nspring.rabbitmq.listener.direct.acknowledge-mode\"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[e._v(\"=\")]),e._v(\"manual\\n\")])])]),t(\"h4\",{attrs:{id:\"_3-消费限流\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-消费限流\"}},[e._v(\"#\")]),e._v(\" 3.消费限流\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"消息限流，就是设置MQ消息到consumer的流量控制\\n\"),t(\"ul\",[t(\"li\",[e._v(\"确保ack机制为手动确认\")]),e._v(\" \"),t(\"li\",[e._v(\"配置perfetch\")])])])]),e._v(\" \"),t(\"h4\",{attrs:{id:\"_4-ttl\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-ttl\"}},[e._v(\"#\")]),e._v(\" 4.TTL\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"TTL Time To Live 存活时间/过期时间\")]),e._v(\" \"),t(\"li\",[e._v(\"当消息到达中间件一定时间内，没被消费，则消息会被自动清除\")]),e._v(\" \"),t(\"li\",[e._v(\"RabbitMQ可以对消息设置过期时间，也可以对整个队列Queue设置过期时间\")])]),e._v(\" \"),t(\"h4\",{attrs:{id:\"_5-死信队列\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-死信队列\"}},[e._v(\"#\")]),e._v(\" 5.死信队列\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"死信队列DLX，Dead Letter Exchange(死信交换机),当消息成为Dead message后，可以被重新发送到另一个交换机，整个交换机就是DLX\")]),e._v(\" \"),t(\"li\",[e._v(\"设置了TTL的消息，如果过期时间没有被消费，而且我们绑定了死信队列，那么过期的消息就会被发到死信队列里（Exchange），然后发送给绑定了整个Exchange的Queue中。\")]),e._v(\" \"),t(\"li\",[e._v(\"消息在三种情况下会成为死信：\\n\"),t(\"ul\",[t(\"li\",[e._v(\"队列Queue的长度到达限制\")]),e._v(\" \"),t(\"li\",[e._v(\"消费者拒绝消费消息，basicNack/basicReject并且不把消息重新放回队列，requeue=false\")]),e._v(\" \"),t(\"li\",[e._v(\"原队列设置了TTL，到期未被消费\")])])]),e._v(\" \"),t(\"li\",[e._v(\"队列绑定死信交换机\\n\"),t(\"ul\",[t(\"li\",[e._v(\"给队列设置参数\"),t(\"code\",[e._v(\"x-dead-letter-exchange\")]),e._v(\"和\"),t(\"code\",[e._v(\"x-dead-letter-routing-key\")])])])])]),e._v(\" \"),t(\"div\",{staticClass:\"custom-block tip\"},[t(\"p\",{staticClass:\"custom-block-title\"},[e._v(\"TIP\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"Dead Letter Exchange(死信交换机) 为什么叫死信队列，是因为其它MQ没有交换机Exchange的概念，为了统一名称，叫死信队列\")]),e._v(\" \"),t(\"li\",[e._v(\"简单理解就是，我们Queue的消息各种原因没办法投递给consumer,于是交给了另一个Exchange，投递给另一个queue\")])])]),e._v(\" \"),t(\"h4\",{attrs:{id:\"_6-延迟队列\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6-延迟队列\"}},[e._v(\"#\")]),e._v(\" 6.延迟队列\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"延迟队列，即消息进入Queue后不会立即被消费，而是要达到指定时间，才会被消费。\")]),e._v(\" \"),t(\"li\",[e._v(\"延迟队列很有用，RabbitMQ没有提供直接的延迟队列功能，但是可以使用\"),t(\"code\",[e._v(\"TTL+ 死信队列DLX\")]),e._v(\"组合实现延迟对了效果\\n\"),t(\"ul\",[t(\"li\",[e._v(\"即我们给一个Queue设置过期时间TTL，当到期以后消息路由到死信交换机放入死信队列。然后对应的consumer处理业务逻辑\")])])])]),e._v(\" \"),t(\"div\",{staticClass:\"custom-block tip\"},[t(\"p\",{staticClass:\"custom-block-title\"},[e._v(\"TIP\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"延迟队列场景\\n\"),t(\"ul\",[t(\"li\",[e._v(\"下单后，30分钟未支付，取消订单，回滚库存\")]),e._v(\" \"),t(\"li\",[e._v(\"新用户注册成功后，7天后发送短信问候\")])])])])]),e._v(\" \"),t(\"h4\",{attrs:{id:\"_7-日志监控\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_7-日志监控\"}},[e._v(\"#\")]),e._v(\" 7.日志监控\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"rabbitMQ默认日志存放路径 /var/log/rabbitmq/rabbit@xxx.log\")]),e._v(\" \"),t(\"li\",[e._v(\"web端 Overview 也可以看监控信息\")]),e._v(\" \"),t(\"li\",[e._v(\"命令查看\\n\"),t(\"ul\",[t(\"li\",[t(\"code\",[e._v(\"rabbitmqctl list_queues\")]),e._v(\" 查看队列\")]),e._v(\" \"),t(\"li\",[t(\"code\",[e._v(\"rabbitmqctl list_exchanges\")]),e._v(\"查看交换机\")]),e._v(\" \"),t(\"li\",[t(\"code\",[e._v(\"rabbitmqctl list_users\")]),e._v(\"查看用户\")]),e._v(\" \"),t(\"li\",[t(\"code\",[e._v(\"rabbitmqctl list_connections\")]),e._v(\"查看连接\")]),e._v(\" \"),t(\"li\",[t(\"code\",[e._v(\"rabbitmqctl list_consumers\")]),e._v(\"查看消费者信息\")]),e._v(\" \"),t(\"li\",[t(\"code\",[e._v(\"rabbitmqctl environment\")]),e._v(\" 查看环境变量\")]),e._v(\" \"),t(\"li\",[t(\"code\",[e._v(\"rabbitmqctl list_queues name messages_unacknowledged\")]),e._v(\"查看未被确认队列\")]),e._v(\" \"),t(\"li\",[t(\"code\",[e._v(\"rabbitmqctl list_queues name memory\")]),e._v(\" 查看单个队列内存使用情况\")]),e._v(\" \"),t(\"li\",[t(\"code\",[e._v(\"rabbitmqctl list_queues name messages_ready\")]),e._v(\"查看准备就绪队列\")])])])]),e._v(\" \"),t(\"h4\",{attrs:{id:\"_8-消息可靠性分析与追踪\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-消息可靠性分析与追踪\"}},[e._v(\"#\")]),e._v(\" 8.消息可靠性分析与追踪\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"在任何消息中间件使用过程中，难免会出现消息异常丢失情况，对于RabbitMQ来说，可能是因为生产者或消费者与RabbitMQ断开了连接，而它们与RabbitMQ又采用了不同的确认机制；也有可能因为交换机Exchange与队列Queue之间不同的转发策略，甚至是交换机没有与队列绑定；另外RabbitMQ的集群策略也可能导致消息丢失。这时候就需要一个好的机制跟踪消息的投递过程，以此协助开发人员定位问题。\")]),e._v(\" \"),t(\"li\",[e._v(\"RabbitMQ中可以使用Firehose和rabbitmq_tracing插件来实现消息追踪\")])]),e._v(\" \"),t(\"h5\",{attrs:{id:\"firehose\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#firehose\"}},[e._v(\"#\")]),e._v(\" Firehose\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"Firehose的机制是将\"),t(\"code\",[e._v(\"生产者投递给rabbitMQ的消息，rabbitMQ投递给消费者的消息\")]),e._v(\"按照指定格式发送到默认的exchange，整个默认的exchange名叫\"),t(\"code\",[e._v(\"amq.rabbitmq.trace\")]),e._v(\",它是一个topic类型的exchange,发送到exchange的RoutingKey为public.exchangename和deliver.queuename.其中exchangename和queuename分别是exchange和queue名称。\\n\"),t(\"ul\",[t(\"li\",[t(\"code\",[e._v(\"rabbitmqctl trace_on\")]),e._v(\" 开启Firehose\")]),e._v(\" \"),t(\"li\",[t(\"code\",[e._v(\"rabbitmqctl trace_off\")]),e._v(\" 关闭Firehose\")]),e._v(\" \"),t(\"li\",[e._v(\"开始trace影响写入性能，适当打开后关闭\")])])])]),e._v(\" \"),t(\"h5\",{attrs:{id:\"rabbitmq-tracing-插件\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#rabbitmq-tracing-插件\"}},[e._v(\"#\")]),e._v(\" rabbitmq_tracing 插件\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"rabbitmq_tracing 原理与Firehose一致，只是这个插件可以在web端使用管理更方便\\n\"),t(\"ul\",[t(\"li\",[t(\"code\",[e._v(\"rabbitmq-plugins enable rabbitmq_tracing\")])]),e._v(\" \"),t(\"li\",[e._v(\"执行命令后，在web管理页面Admin就可以看到Tracing选项\")])])]),e._v(\" \"),t(\"li\",[e._v(\"配置好web页面的Tracing后，发送消息可以在此看到tracing.log\")])]),e._v(\" \"),t(\"h3\",{attrs:{id:\"二、rabbitmq应用问题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二、rabbitmq应用问题\"}},[e._v(\"#\")]),e._v(\" 二、RabbitMQ应用问题\")]),e._v(\" \"),t(\"h4\",{attrs:{id:\"_1-消息可靠性保障-消息补偿机制\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-消息可靠性保障-消息补偿机制\"}},[e._v(\"#\")]),e._v(\" 1.消息可靠性保障 \"),t(\"code\",[e._v(\"消息补偿机制\")])]),e._v(\" \"),t(\"img\",{attrs:{src:e.$withBase(\"/mq/6.png\"),alt:\"dock\"}}),e._v(\" \"),t(\"ul\",[t(\"li\",[e._v(\"第一步，生产者把要发的消息入库，并且发送给队列Q1，Consumer消费消息\")]),e._v(\" \"),t(\"li\",[e._v(\"第二步，Consumer消费消息以后，也会发送一条消费成功的消息给Q2，回调检查服务监听此Queue,将消息保存MDB\")]),e._v(\" \"),t(\"li\",[e._v(\"第三步，此时刚才发送消息的时候，同时发送了一条延迟队列的信息Q3也被回调检查服务监听到了，此时回调检查服务拿Q3的消息区MDB中检查有没有此消息，如果刚才第二步，Consumer消息未消费成功的话，此时MDB中就没有该消息。\")]),e._v(\" \"),t(\"li\",[e._v(\"第四步，如果有MDB数据有，流程结束，没有消息的话，会重新调Producer重新发送消息到Q1和Q3\")]),e._v(\" \"),t(\"li\",[e._v(\"还有一种极端场景就是Producer发送Q1、Q3都失败了，这时候我们有个定时检查服务，会对比Producer的DB和MDB数据是否一致（DB数据多与MDB），这时候定时任务通知Producer把多的数据继续发送给MQ\")])]),e._v(\" \"),t(\"h4\",{attrs:{id:\"_2-消息幂等性\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-消息幂等性\"}},[e._v(\"#\")]),e._v(\" 2.消息幂等性\")]),e._v(\" \"),t(\"ul\",[t(\"li\",[t(\"code\",[e._v(\"消息补偿机制\")]),e._v(\" 有可能导致消息的重复发送，这时候我们需要考虑消息幂等性，保证消息在重复消费的幂等问题\\n\"),t(\"ul\",[t(\"li\",[e._v(\"解决方案就是消息接收方接收消息也落DB，接收消息第一步先判断数据库是否存在该消息\")]),e._v(\" \"),t(\"li\",[t(\"code\",[e._v(\"乐观锁解决方案\")]),e._v(\"也可以，在业务数据操作时判断是否已经有消息被消费\")])])])])])}),[],!1,null,null,null);a.default=_.exports}}]);","extractedComments":[]}